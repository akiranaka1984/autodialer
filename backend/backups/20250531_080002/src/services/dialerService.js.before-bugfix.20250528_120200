// backend/src/services/dialerService.js - å®Œå…¨ä¿®æ­£ç‰ˆ
const db = require('./database');
const logger = require('./logger');

class DialerService {
  constructor() {
    this.activeCampaigns = new Map();
    this.activeCalls = new Map();
    this.initialized = false;
    this.dialerIntervalId = null;
    this.isProcessing = false;
    this.lastProcessTime = null;
    this.errorCount = 0;
    this.maxErrors = 3;
    this.dialInterval = 10000; // 10ç§’é–“éš”
    this.processTimeout = 8000; // 8ç§’ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ
    this.enabled = true; // ğŸ”¥ å®Œå…¨åœæ­¢ãƒ•ãƒ©ã‚°
  }

  // ğŸš€ åˆæœŸåŒ–ï¼ˆå®‰å…¨ç‰ˆï¼‰
  async initialize() {
    if (this.initialized) {
      logger.info('DialerService ã¯æ—¢ã«åˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã™');
      return true;
    }
    
    try {
      logger.info('ğŸš€ DialerService åˆæœŸåŒ–é–‹å§‹');
      
      // ğŸ”¥ ç’°å¢ƒå¤‰æ•°ã§ã®ç„¡åŠ¹åŒ–ãƒã‚§ãƒƒã‚¯
      if (process.env.DISABLE_AUTO_DIALER === 'true') {
        logger.info('ğŸ›‘ AUTO_DIALERç„¡åŠ¹åŒ–ãƒ•ãƒ©ã‚°ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã™');
        this.enabled = false;
        this.initialized = true;
        return true;
      }
      
      // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚­ãƒ£ãƒ³ãƒšãƒ¼ãƒ³ã‚’å–å¾—ï¼ˆå®‰å…¨ç‰ˆï¼‰
      const activeCampaigns = await this.queryWithTimeout(`
        SELECT c.id, c.name, c.max_concurrent_calls, c.caller_id_id, 
               ci.number as caller_id_number
        FROM campaigns c
        JOIN caller_ids ci ON c.caller_id_id = ci.id
        WHERE c.status = 'active' AND ci.active = true
        LIMIT 5
      `, [], 5000);
      
      logger.info(`ğŸ“Š ${activeCampaigns.length}ä»¶ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚­ãƒ£ãƒ³ãƒšãƒ¼ãƒ³ã‚’æ¤œå‡º`);
      
      // ğŸ”¥ ç™ºä¿¡å¯¾è±¡ã®é€£çµ¡å…ˆãŒã‚ã‚‹ã‚­ãƒ£ãƒ³ãƒšãƒ¼ãƒ³ã®ã¿å‡¦ç†
      let validCampaigns = 0;
      for (const campaign of activeCampaigns) {
        const [contactCount] = await this.queryWithTimeout(
          'SELECT COUNT(*) as count FROM contacts WHERE campaign_id = ? AND status = "pending" LIMIT 1',
          [campaign.id], 3000
        );
        
	if (contactCount && contactCount.length > 0 && contactCount[0] && contactCount[0].count > 0) {
          this.activeCampaigns.set(campaign.id, {
            id: campaign.id,
            name: campaign.name,
            maxConcurrentCalls: Math.min(campaign.max_concurrent_calls || 1, 2),
            callerIdId: campaign.caller_id_id,
            callerIdNumber: campaign.caller_id_number,
            activeCalls: 0,
            status: 'active',
            lastDialTime: null,
            failCount: 0
          });
          validCampaigns++;
        }
      }
      
      // ğŸ”¥ æœ‰åŠ¹ãªã‚­ãƒ£ãƒ³ãƒšãƒ¼ãƒ³ãŒã‚ã‚‹å ´åˆã®ã¿è‡ªå‹•ç™ºä¿¡é–‹å§‹
      if (validCampaigns > 0 && this.enabled) {
        this.startDialerJobSafe();
        logger.info(`âœ… ${validCampaigns}ä»¶ã®ã‚­ãƒ£ãƒ³ãƒšãƒ¼ãƒ³ã§è‡ªå‹•ç™ºä¿¡é–‹å§‹`);
      } else {
        logger.info('â„¹ï¸ ç™ºä¿¡å¯¾è±¡ãªã—ã€‚è‡ªå‹•ç™ºä¿¡ã¯ç„¡åŠ¹');
        this.enabled = false;
      }
      
      this.initialized = true;
      return true;
    } catch (error) {
      logger.error('âŒ DialerService åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼:', error);
      this.enabled = false;
      this.initialized = false;
      return false;
    }
  }

  // ğŸ”„ å®‰å…¨ãªè‡ªå‹•ç™ºä¿¡ã‚¸ãƒ§ãƒ–é–‹å§‹
  startDialerJobSafe() {
    if (!this.enabled) {
      logger.info('ğŸ›‘ DialerServiceç„¡åŠ¹ã®ãŸã‚ç™ºä¿¡ã‚¸ãƒ§ãƒ–ã¯é–‹å§‹ã•ã‚Œã¾ã›ã‚“');
      return false;
    }
    
    // æ—¢å­˜ã‚¸ãƒ§ãƒ–åœæ­¢
    if (this.dialerIntervalId) {
      clearInterval(this.dialerIntervalId);
      this.dialerIntervalId = null;
    }
    
    // ğŸ”¥ å®‰å…¨ãªé–“éš”ã§é–‹å§‹
    this.dialerIntervalId = setInterval(async () => {
      // ç„¡åŠ¹åŒ–ãƒã‚§ãƒƒã‚¯
      if (!this.enabled) {
        logger.info('ğŸ›‘ ç„¡åŠ¹åŒ–ãƒ•ãƒ©ã‚°æ¤œå‡º - ç™ºä¿¡ã‚¸ãƒ§ãƒ–åœæ­¢');
        this.stopDialerJob();
        return;
      }
      
      // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚­ãƒ£ãƒ³ãƒšãƒ¼ãƒ³æ•°ãƒã‚§ãƒƒã‚¯
      if (this.activeCampaigns.size === 0) {
        logger.info('â¹ï¸ ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚­ãƒ£ãƒ³ãƒšãƒ¼ãƒ³ãªã— - ç™ºä¿¡ã‚¸ãƒ§ãƒ–åœæ­¢');
        this.stopDialerJob();
        return;
      }
      
      // å‡¦ç†ä¸­ãƒã‚§ãƒƒã‚¯
      if (this.isProcessing) {
        logger.debug('â­ï¸ å‡¦ç†ä¸­ã®ãŸã‚ã‚¹ã‚­ãƒƒãƒ—');
        return;
      }
      
      // ã‚¨ãƒ©ãƒ¼ä¸Šé™ãƒã‚§ãƒƒã‚¯
      if (this.errorCount >= this.maxErrors) {
        logger.warn(`ğŸ›‘ ã‚¨ãƒ©ãƒ¼ä¸Šé™(${this.maxErrors})ã«é”ã—ãŸãŸã‚åœæ­¢`);
        this.stopDialerJob();
        return;
      }
      
      // å®‰å…¨ãªå‡¦ç†å®Ÿè¡Œ
      try {
        await this.processDialerQueueSafe();
      } catch (error) {
        this.errorCount++;
        logger.error(`âŒ ç™ºä¿¡ã‚¸ãƒ§ãƒ–ã‚¨ãƒ©ãƒ¼ (${this.errorCount}/${this.maxErrors}):`, error.message);
      }
    }, this.dialInterval);
    
    logger.info(`ğŸ”¥ å®‰å…¨ãªè‡ªå‹•ç™ºä¿¡ã‚¸ãƒ§ãƒ–é–‹å§‹: é–“éš”=${this.dialInterval}ms`);
    return true;
  }

  // ğŸ›‘ ç™ºä¿¡ã‚¸ãƒ§ãƒ–åœæ­¢
  stopDialerJob() {
    if (this.dialerIntervalId) {
      clearInterval(this.dialerIntervalId);
      this.dialerIntervalId = null;
      this.isProcessing = false;
      logger.info('ğŸ›‘ è‡ªå‹•ç™ºä¿¡ã‚¸ãƒ§ãƒ–ã‚’åœæ­¢ã—ã¾ã—ãŸ');
      return true;
    }
    return false;
  }

  // ğŸ”„ å®‰å…¨ãªç™ºä¿¡ã‚­ãƒ¥ãƒ¼å‡¦ç†
  async processDialerQueueSafe() {
    this.isProcessing = true;
    this.lastProcessTime = new Date();
    
    try {
      await Promise.race([
        this.processDialerQueueLight(),
        new Promise((_, reject) => 
          setTimeout(() => reject(new Error('ç™ºä¿¡å‡¦ç†ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ')), this.processTimeout)
        )
      ]);
      
      this.errorCount = 0; // æˆåŠŸæ™‚ãƒªã‚»ãƒƒãƒˆ
    } catch (error) {
      throw error;
    } finally {
      this.isProcessing = false;
    }
  }

  // ğŸ”„ è»½é‡ç™ºä¿¡ã‚­ãƒ¥ãƒ¼å‡¦ç†
  async processDialerQueueLight() {
    try {
      let totalAttempts = 0;
      const maxAttempts = 2; // ğŸ”¥ 1å›ã‚ãŸã‚Šæœ€å¤§2ä»¶
      
      for (const [campaignId, campaign] of this.activeCampaigns.entries()) {
        if (totalAttempts >= maxAttempts || !this.enabled) break;
        if (campaign.status !== 'active') continue;
        
        // åŒæ™‚ç™ºä¿¡æ•°ãƒã‚§ãƒƒã‚¯
        if (campaign.activeCalls >= campaign.maxConcurrentCalls) continue;
        
        // ğŸ”¥ ç™ºä¿¡å¯¾è±¡ã‚’1ä»¶ã ã‘å–å¾—
        const contacts = await this.queryWithTimeout(`
          SELECT id, phone, name, company 
          FROM contacts 
          WHERE campaign_id = ? AND status = 'pending' 
          LIMIT 1
        `, [campaignId], 3000);
        
        if (contacts.length === 0) {
          // ç™ºä¿¡å¯¾è±¡ãªã—ã®å ´åˆã¯ã‚­ãƒ£ãƒ³ãƒšãƒ¼ãƒ³å®Œäº†ãƒã‚§ãƒƒã‚¯
          await this.checkCampaignCompletion(campaignId);
          continue;
        }
        
        // 1ä»¶ã®ã¿ç™ºä¿¡è©¦è¡Œ
        const contact = contacts[0];
        const result = await this.dialContactLight(campaign, contact);
        if (result) {
          campaign.activeCalls++;
          totalAttempts++;
        }
        
        // ç™ºä¿¡é–“éš”
        if (totalAttempts < maxAttempts) {
          await new Promise(resolve => setTimeout(resolve, 2000));
        }
      }
      
      logger.debug(`ğŸ“ ç™ºä¿¡ã‚µã‚¤ã‚¯ãƒ«å®Œäº†: ${totalAttempts}ä»¶å®Ÿè¡Œ`);
    } catch (error) {
      logger.error('è»½é‡ç™ºä¿¡ã‚­ãƒ¥ãƒ¼å‡¦ç†ã‚¨ãƒ©ãƒ¼:', error);
      throw error;
    }
  }

  // ğŸ“ è»½é‡ç™ºä¿¡å‡¦ç†
  async dialContactLight(campaign, contact) {
    try {
      logger.info(`ğŸ“ ç™ºä¿¡: ${contact.phone}`);
      
      // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°
      await this.queryWithTimeout(
        'UPDATE contacts SET status = ? WHERE id = ?',
        ['called', contact.id], 2000
      );
      
      // ç°¡å˜ãªç™ºä¿¡ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
      const params = {
        phoneNumber: contact.phone,
        context: 'autodialer',
        callerID: `"${campaign.name}" <${campaign.callerIdNumber}>`,
        variables: {
          CAMPAIGN_ID: campaign.id,
          CONTACT_ID: contact.id,
          AUTO_DIAL: 'true'
        }
      };
      
      // ç™ºä¿¡å®Ÿè¡Œ
      const callService = require('./callService');
      const result = await callService.originate(params);
      
      // é€šè©±ãƒ­ã‚°è¨˜éŒ²
      await this.queryWithTimeout(`
        INSERT INTO call_logs 
        (contact_id, campaign_id, caller_id_id, call_id, start_time, status, call_provider)
        VALUES (?, ?, ?, ?, NOW(), 'ORIGINATING', ?)
      `, [contact.id, campaign.id, campaign.callerIdId, result.ActionID, result.provider || 'sip'], 3000);
      
      // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚³ãƒ¼ãƒ«è¨˜éŒ²
      this.activeCalls.set(result.ActionID, {
        id: result.ActionID,
        contactId: contact.id,
        campaignId: campaign.id,
        startTime: new Date(),
        status: 'active'
      });
      
      logger.info(`âœ… ç™ºä¿¡æˆåŠŸ: ${contact.phone}`);
      return true;
    } catch (error) {
      logger.error(`âŒ ç™ºä¿¡ã‚¨ãƒ©ãƒ¼: ${contact.phone}`, error);
      
      // ã‚¨ãƒ©ãƒ¼æ™‚ã¯å¤±æ•—ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã«æ›´æ–°
      await this.queryWithTimeout(
        'UPDATE contacts SET status = ? WHERE id = ?',
        ['failed', contact.id], 2000
      ).catch(() => {});
      
      return false;
    }
  }

  // âœ… ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆä»˜ãã‚¯ã‚¨ãƒª
  async queryWithTimeout(sql, params = [], timeoutMs = 5000) {
    return new Promise(async (resolve, reject) => {
      const timer = setTimeout(() => {
        reject(new Error(`ã‚¯ã‚¨ãƒªã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ: ${timeoutMs}ms`));
      }, timeoutMs);
      
      try {
        const [result] = await db.query(sql, params);
        clearTimeout(timer);
        resolve(result);
      } catch (error) {
        clearTimeout(timer);
        reject(error);
      }
    });
  }

  // ğŸ ã‚­ãƒ£ãƒ³ãƒšãƒ¼ãƒ³å®Œäº†ãƒã‚§ãƒƒã‚¯
  async checkCampaignCompletion(campaignId) {
    try {
      const [pendingCount] = await this.queryWithTimeout(
        'SELECT COUNT(*) as count FROM contacts WHERE campaign_id = ? AND status = "pending"',
        [campaignId], 3000
      );
      
      if (pendingCount[0].count === 0) {
        await this.completeCampaign(campaignId);
      }
    } catch (error) {
      logger.error(`ã‚­ãƒ£ãƒ³ãƒšãƒ¼ãƒ³å®Œäº†ãƒã‚§ãƒƒã‚¯ã‚¨ãƒ©ãƒ¼: ${campaignId}`, error);
    }
  }

  // ğŸš€ ã‚­ãƒ£ãƒ³ãƒšãƒ¼ãƒ³é–‹å§‹
  async startCampaign(campaignId) {
    try {
      logger.info(`ğŸš€ ã‚­ãƒ£ãƒ³ãƒšãƒ¼ãƒ³é–‹å§‹: ID=${campaignId}`);
      
      const campaigns = await this.queryWithTimeout(`
        SELECT c.id, c.name, c.max_concurrent_calls, c.caller_id_id, 
               ci.number as caller_id_number
        FROM campaigns c
        JOIN caller_ids ci ON c.caller_id_id = ci.id
        WHERE c.id = ? AND ci.active = true
      `, [campaignId], 5000);
      
      if (campaigns.length === 0) {
        throw new Error('ã‚­ãƒ£ãƒ³ãƒšãƒ¼ãƒ³ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
      }
      
      const campaign = campaigns[0];
      
      await this.queryWithTimeout(
        'UPDATE campaigns SET status = ? WHERE id = ?',
        ['active', campaignId], 3000
      );
      
      this.activeCampaigns.set(campaignId, {
        id: campaign.id,
        name: campaign.name,
        maxConcurrentCalls: Math.min(campaign.max_concurrent_calls || 1, 2),
        callerIdId: campaign.caller_id_id,
        callerIdNumber: campaign.caller_id_number,
        activeCalls: 0,
        status: 'active',
        lastDialTime: new Date(),
        failCount: 0
      });
      
      // ç™ºä¿¡ã‚¸ãƒ§ãƒ–ãŒåœæ­¢ã—ã¦ã„ã‚‹å ´åˆã¯é–‹å§‹
      if (!this.dialerIntervalId && this.enabled) {
        this.startDialerJobSafe();
      }
      
      logger.info(`âœ… ã‚­ãƒ£ãƒ³ãƒšãƒ¼ãƒ³é–‹å§‹æˆåŠŸ: ${campaign.name}`);
      return true;
    } catch (error) {
      logger.error(`âŒ ã‚­ãƒ£ãƒ³ãƒšãƒ¼ãƒ³é–‹å§‹ã‚¨ãƒ©ãƒ¼: ${error.message}`);
      return false;
    }
  }

  // ğŸ›‘ ã‚­ãƒ£ãƒ³ãƒšãƒ¼ãƒ³åœæ­¢
  async pauseCampaign(campaignId) {
    try {
      await this.queryWithTimeout(
        'UPDATE campaigns SET status = ? WHERE id = ?',
        ['paused', campaignId], 3000
      );
      
      this.activeCampaigns.delete(campaignId);
      
      if (this.activeCampaigns.size === 0) {
        this.stopDialerJob();
      }
      
      logger.info(`ğŸ›‘ ã‚­ãƒ£ãƒ³ãƒšãƒ¼ãƒ³åœæ­¢: ID=${campaignId}`);
      return true;
    } catch (error) {
      logger.error(`ã‚­ãƒ£ãƒ³ãƒšãƒ¼ãƒ³åœæ­¢ã‚¨ãƒ©ãƒ¼: ${campaignId}`, error);
      return false;
    }
  }

  // ğŸ ã‚­ãƒ£ãƒ³ãƒšãƒ¼ãƒ³å®Œäº†
  async completeCampaign(campaignId) {
    try {
      await this.queryWithTimeout(
        'UPDATE campaigns SET status = ? WHERE id = ?',
        ['completed', campaignId], 3000
      );
      
      this.activeCampaigns.delete(campaignId);
      
      if (this.activeCampaigns.size === 0) {
        this.stopDialerJob();
      }
      
      logger.info(`ğŸ ã‚­ãƒ£ãƒ³ãƒšãƒ¼ãƒ³å®Œäº†: ${campaignId}`);
      return true;
    } catch (error) {
      logger.error(`ã‚­ãƒ£ãƒ³ãƒšãƒ¼ãƒ³å®Œäº†ã‚¨ãƒ©ãƒ¼: ${campaignId}`, error);
      return false;
    }
  }

  // ğŸ“ é€šè©±çµ‚äº†å‡¦ç†
  async handleCallEnd(callId, duration, disposition, keypress) {
    try {
      if (!this.activeCalls.has(callId)) {
        logger.debug(`æœªçŸ¥ã®é€šè©±ID: ${callId}`);
        return false;
      }
      
      const call = this.activeCalls.get(callId);
      
      await this.queryWithTimeout(`
        UPDATE call_logs
        SET end_time = NOW(), duration = ?, status = ?, keypress = ?
        WHERE call_id = ?
      `, [duration, disposition, keypress, callId], 3000);
      
      let contactStatus = 'completed';
      if (keypress === '9') {
        contactStatus = 'dnc';
        // DNCç™»éŒ²å‡¦ç†
        const contacts = await this.queryWithTimeout(
          'SELECT phone FROM contacts WHERE id = ?',
          [call.contactId], 2000
        );
        if (contacts.length > 0) {
          await this.queryWithTimeout(
            'INSERT IGNORE INTO dnc_list (phone, reason) VALUES (?, ?)',
            [contacts[0].phone, 'ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒªã‚¯ã‚¨ã‚¹ãƒˆ'], 2000
          );
        }
      }
      
      await this.queryWithTimeout(
        'UPDATE contacts SET status = ? WHERE id = ?',
        [contactStatus, call.contactId], 2000
      );
      
      // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚³ãƒ¼ãƒ«æ•°ã‚’æ¸›ã‚‰ã™
      if (this.activeCampaigns.has(call.campaignId)) {
        const campaign = this.activeCampaigns.get(call.campaignId);
        campaign.activeCalls = Math.max(0, campaign.activeCalls - 1);
      }
      
      this.activeCalls.delete(callId);
      
      logger.info(`âœ… é€šè©±çµ‚äº†å‡¦ç†å®Œäº†: ${callId}`);
      return true;
    } catch (error) {
      logger.error(`âŒ é€šè©±çµ‚äº†å‡¦ç†ã‚¨ãƒ©ãƒ¼: ${callId}`, error);
      return false;
    }
  }

  // ğŸ“Š ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹å–å¾—
  getHealthStatus() {
    return {
      timestamp: new Date().toISOString(),
      initialized: this.initialized,
      enabled: this.enabled,
      dialerJobRunning: this.dialerIntervalId !== null,
      isProcessing: this.isProcessing,
      lastProcessTime: this.lastProcessTime,
      errorCount: this.errorCount,
      maxErrors: this.maxErrors,
      activeCampaigns: {
        count: this.activeCampaigns.size,
        details: Array.from(this.activeCampaigns.entries()).map(([id, campaign]) => ({
          id: id,
          name: campaign.name,
          status: campaign.status,
          activeCalls: campaign.activeCalls,
          maxConcurrentCalls: campaign.maxConcurrentCalls
        }))
      },
      activeCalls: {
        count: this.activeCalls.size
      }
    };
  }

  // ğŸš¨ ç·Šæ€¥åœæ­¢
  async emergencyStopAll(reason = 'ç·Šæ€¥åœæ­¢') {
    logger.warn(`ğŸš¨ ç·Šæ€¥åœæ­¢å®Ÿè¡Œ: ${reason}`);
    
    this.enabled = false;
    this.stopDialerJob();
    
    const stoppedCampaigns = [];
    for (const [campaignId, campaign] of this.activeCampaigns.entries()) {
      try {
        await this.pauseCampaign(campaignId);
        stoppedCampaigns.push({ id: campaignId, name: campaign.name });
      } catch (error) {
        logger.error(`ç·Šæ€¥åœæ­¢ã‚¨ãƒ©ãƒ¼: ${campaignId}`, error);
      }
    }
    
    this.errorCount = 0;
    this.isProcessing = false;
    
    logger.warn(`ğŸš¨ ç·Šæ€¥åœæ­¢å®Œäº†: ${stoppedCampaigns.length}ã‚­ãƒ£ãƒ³ãƒšãƒ¼ãƒ³åœæ­¢`);
    
    return {
      timestamp: new Date().toISOString(),
      reason: reason,
      stoppedCampaigns: stoppedCampaigns,
      success: true
    };
  }
}

const dialerService = new DialerService();
module.exports = dialerService;
